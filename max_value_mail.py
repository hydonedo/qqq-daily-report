# -*- coding: utf-8 -*-
"""max-value-mail.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MVFweBMXmc1UbuD7kB-iEtl1QU_PrKIa
"""

# Install required packages
!pip install yfinance pandas numpy schedule --quiet

import yfinance as yf
import pandas as pd
import numpy as np
import smtplib
from email.mime.text import MIMEText
from datetime import datetime, timedelta
import time
import schedule
import pytz
import warnings

# Suppress warnings
warnings.filterwarnings("ignore", category=RuntimeWarning)
warnings.filterwarnings("ignore", category=FutureWarning)

# === Configuration (Modify These Variables) ===
# Data Settings
TICKER = "QQQ"
START_DATE = "2010-01-01"  # Fetch enough historical data for MAs
REPORT_TIME = "06:00"  # 6 AM New York time
TIMEZONE = "America/New_York"

# Strategy Parameters (From the first script)
MA_PERIODS = [388, 374, 172]
WEIGHTS = [0.0092, 0.9978, 0.9712]
RSI_OVERSOLD = 34.72
RSI_OVERBOUGHT = 82.26
TREND_MA_PERIOD = 50
TREND_MA_TOLERANCE = 0.05
MIN_HOLDING_PERIOD = 20

# Email Settings
EMAIL_FROM = "hy.yi.huang@gmail.com"
EMAIL_TO = "hy.yi.huang@gmail.com"
EMAIL_SUBJECT = "ðŸ“Š QQQ Daily Report - Morning Update"
EMAIL_APP_PASSWORD = "xxywpbqhzljuhkvf"
# === End Configuration ===

# State Tracking
in_position = False
days_held = 0
last_entry_date = None
last_signal = None
last_signal_date = None
last_signal_percentage = 0.0

# Function to send email report
def send_email_report(subject, body):
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = EMAIL_FROM
    msg['To'] = EMAIL_TO

    try:
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(EMAIL_FROM, EMAIL_APP_PASSWORD)
            server.sendmail(EMAIL_FROM, EMAIL_TO, msg.as_string())
        print(f"Email report sent at {datetime.now(pytz.timezone(TIMEZONE))}")
    except Exception as e:
        print(f"Failed to send email report: {e}")

# Function to fetch and prepare data
def fetch_prepare_data(ticker, start_date):
    try:
        data = yf.download(ticker, start=start_date, end=None, auto_adjust=False, progress=False)
        if data.empty:
            raise ValueError("No data fetched.")
    except Exception as e:
        print(f"Error fetching data: {e}")
        return None

    if 'Adj Close' in data.columns:
        price_col = 'Adj Close'
    elif 'Close' in data.columns:
        price_col = 'Close'
        print("Warning: 'Adj Close' not found, falling back to 'Close'.")
    else:
        print("Error: Neither 'Adj Close' nor 'Close' found in data.")
        return None

    data = data[[price_col]].rename(columns={price_col: 'Close'})

    for p in MA_PERIODS:
        data[f'MA_{p}'] = data['Close'].rolling(window=p, min_periods=p).mean()

    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14, min_periods=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14, min_periods=14).mean()
    rs = gain / loss
    data['RSI'] = 100 - (100 / (1 + rs))

    data['Trend_MA'] = data['Close'].rolling(window=TREND_MA_PERIOD, min_periods=TREND_MA_PERIOD).mean()

    data = data.dropna()
    return data

# Function to generate trading signal
def generate_signal(data, in_position, days_held):
    if len(data) < 2:
        return None, 0.0

    latest = data.iloc[-1]
    previous = data.iloc[-2]

    price = latest['Close']
    prev_price = previous['Close']
    rsi = latest['RSI']
    trend_ma = latest['Trend_MA']

    buy_signal = 0.0
    sell_signal = 0.0

    for p, weight in zip(MA_PERIODS, WEIGHTS):
        ma_col = f'MA_{p}'
        ma_value = latest[ma_col]
        prev_ma = previous[ma_col]

        if pd.notna(price) and pd.notna(prev_price) and pd.notna(ma_value) and pd.notna(prev_ma) and pd.notna(rsi) and pd.notna(trend_ma):
            if (prev_price < prev_ma and price >= ma_value and
                rsi < RSI_OVERBOUGHT and price >= trend_ma * (1 - TREND_MA_TOLERANCE)):
                buy_signal += weight
            if (price < ma_value and rsi > RSI_OVERSOLD and
                price < trend_ma * (1 - TREND_MA_TOLERANCE)):
                sell_signal += weight

    buy_signal = min(buy_signal, 1.0)
    sell_signal = min(sell_signal, 1.0)

    if in_position and sell_signal > 0 and days_held >= MIN_HOLDING_PERIOD:
        return "SELL", sell_signal
    elif not in_position and buy_signal > 0:
        return "BUY", buy_signal
    else:
        return None, 0.0

# Function to fetch QQQ news
def fetch_qqq_news(ticker):
    try:
        ticker_obj = yf.Ticker(ticker)
        news = ticker_obj.news
        if not news:
            return "No recent news available for QQQ."
        news_summary = "Recent News Headlines for QQQ:\n"
        for i, article in enumerate(news[:3]):  # Limit to 3 articles
            title = article.get('title', 'N/A')
            publisher = article.get('publisher', 'N/A')
            link = article.get('link', 'N/A')
            news_summary += f"{i+1}. {title} ({publisher})\n   Link: {link}\n"
        return news_summary
    except Exception as e:
        print(f"Error fetching news: {e}")
        return "Error fetching news for QQQ."

# Function to generate the daily report
def generate_daily_report():
    global in_position, days_held, last_entry_date, last_signal, last_signal_date, last_signal_percentage

    print(f"Generating daily report at {datetime.now(pytz.timezone(TIMEZONE))}...")

    # Fetch historical data
    data = fetch_prepare_data(TICKER, START_DATE)
    if data is None or data.empty:
        body = "Error: Failed to fetch data for QQQ. Please check the script."
        send_email_report(EMAIL_SUBJECT, body)
        return

    # Fetch the latest data
    try:
        latest_data = yf.download(TICKER, period="5d", interval="1d", auto_adjust=False, progress=False)
        if latest_data.empty:
            print("No new data available for the report.")
            return
    except Exception as e:
        print(f"Error fetching latest data: {e}")
        return

    if 'Adj Close' in latest_data.columns:
        price_col = 'Adj Close'
    elif 'Close' in latest_data.columns:
        price_col = 'Close'
    else:
        print("Error: Neither 'Adj Close' nor 'Close' found in latest data.")
        return

    latest_data = latest_data[[price_col]].rename(columns={price_col: 'Close'})
    latest_date = latest_data.index[-1]
    if latest_date in data.index:
        data.loc[latest_date, 'Close'] = latest_data['Close'].iloc[-1]
    else:
        data = pd.concat([data, latest_data])

    for p in MA_PERIODS:
        data[f'MA_{p}'] = data['Close'].rolling(window=p, min_periods=p).mean()

    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14, min_periods=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14, min_periods=14).mean()
    rs = gain / loss
    data['RSI'] = 100 - (100 / (1 + rs))

    data['Trend_MA'] = data['Close'].rolling(window=TREND_MA_PERIOD, min_periods=TREND_MA_PERIOD).mean()

    data_clean = data.dropna()

    # Update days held
    if in_position and last_entry_date is not None:
        days_held = (latest_date - last_entry_date).days
    else:
        days_held = 0

    # Generate signal
    signal, percentage = generate_signal(data_clean, in_position, days_held)

    # Update state if a signal is generated
    if signal:
        price = data_clean['Close'].iloc[-1]
        if signal == "BUY":
            in_position = True
            last_entry_date = latest_date
            days_held = 0
        elif signal == "SELL":
            in_position = False
            last_entry_date = None
            days_held = 0
        last_signal = signal
        last_signal_date = latest_date
        last_signal_percentage = percentage

    # Calculate QQQ performance metrics
    latest_price = data_clean['Close'].iloc[-1]
    one_day_change = (data_clean['Close'].iloc[-1] / data_clean['Close'].iloc[-2] - 1) * 100 if len(data_clean) >= 2 else 0.0
    five_day_change = (data_clean['Close'].iloc[-1] / data_clean['Close'].iloc[-5] - 1) * 100 if len(data_clean) >= 5 else 0.0
    thirty_day_change = (data_clean['Close'].iloc[-1] / data_clean['Close'].iloc[-30] - 1) * 100 if len(data_clean) >= 30 else 0.0
    latest_rsi = data_clean['RSI'].iloc[-1]
    latest_trend_ma = data_clean['Trend_MA'].iloc[-1]
    ma_values = {f'MA_{p}': data_clean[f'MA_{p}'].iloc[-1] for p in MA_PERIODS}

    # Fetch news
    news_summary = fetch_qqq_news(TICKER)

    # Generate the report body
    report_date = datetime.now(pytz.timezone(TIMEZONE)).strftime('%Y-%m-%d')
    body = (
        f"QQQ Daily Report - {report_date}\n\n"
        f"Generated at: {datetime.now(pytz.timezone(TIMEZONE)).strftime('%Y-%m-%d %H:%M:%S %Z')}\n\n"
        f"--- Strategy Status ---\n"
        f"In Position: {in_position}\n"
        f"Days Held: {days_held}\n"
        f"Last Signal: {last_signal if last_signal else 'None'}\n"
        f"Last Signal Date: {last_signal_date.strftime('%Y-%m-%d') if last_signal_date else 'N/A'}\n"
        f"Last Signal Percentage: {last_signal_percentage:.2%}\n\n"
        f"--- Potential Signal for Today ---\n"
        f"Signal: {signal if signal else 'None'}\n"
        f"Percentage: {percentage:.2%}\n"
        f"Action: {f'Consider {signal.lower()}ing {percentage:.2%} of your holdings.' if signal else 'No action recommended.'}\n\n"
        f"--- QQQ Performance Summary ---\n"
        f"Latest Price: ${latest_price:.2f}\n"
        f"1-Day Change: {one_day_change:.2f}%\n"
        f"5-Day Change: {five_day_change:.2f}%\n"
        f"30-Day Change: {thirty_day_change:.2f}%\n"
        f"RSI (14-day): {latest_rsi:.2f}\n"
        f"Trend MA ({TREND_MA_PERIOD}-day): ${latest_trend_ma:.2f}\n"
        f"Moving Averages:\n"
    )
    for p, ma_value in ma_values.items():
        body += f"  {p}: ${ma_value:.2f}\n"
    body += f"\n--- Market News ---\n{news_summary}\n\n"
    body += "Note: This report does not account for transaction fees (0.1%) or profit tax (10% on sales)."

    # Send the report
    send_email_report(EMAIL_SUBJECT, body)

# Schedule the report to run at 6 AM New York time
schedule.every().day.at(REPORT_TIME, TIMEZONE).do(generate_daily_report)

# Main loop to run the scheduler
print(f"Scheduler started. Waiting to generate daily report at {REPORT_TIME} {TIMEZONE}...")
while True:
    schedule.run_pending()
    time.sleep(60)  # Check every minute